GOのプログラムには最低1つゴールーチンがある（つまりメインゴールーチン）
go ファンクション
で簡単に起動する
func main() {
    go sayHello()
    //他の処理
}
func sayHello() {
    fmt.Printf("Hello World!")
}

無名関数でも起動できる
go func() {
    fmt.Printf("Hello World")
}() //即時呼び出し

○　ゴールーチンについて
OSのスレッドではなく、グリーンスレッド（言語のランタイムに管理されるスレッド）でもない
ゴールーチンはcoroutineとして知られる高水準の抽象化
coroutineは単にプリエンプティブでない並行処理のサブルーチン
つまり割り込みされることがない一連の実行のこと
変わりにcoroutineは一時停止や再エントリーを許す複数のポイントがある

一方、ゴールーチンが独特なのは、GOのランタイムと密結合していること
ゴールーチンでは一時停止や再エントリーのポイントは定義していない
（プログラマーに解法されていない。ランタイム側で勝手に切り替える）
GOのランタイムは、ゴールーチンの実行時のふるまいを観察し、
ゴールーチンがブロックしたら自動的に一時停止し、ブロックが解法されたら再開する
これはある意味プリエンプティブなことだが、ブロックがなければ割り込みはない

coroutine、ゴールーチンは暗黙的には並行処理の構成要素だが、
並行性はcoroutineの性質ではない
並行である場合、何かが複数のcoroutineを同時管理し、それぞれに実行機会を与える必要がある
複数のcoroutineを逐次実行してCPUコア以上に並列処理しているように見せることは出来、
実際にGOではそうなっている

GOがゴールーチンをホストする機構はM:Nスケジューラ
M個のグリーンスレッドをN個のOSスレッドに対応させるもの
ゴールーチンはグリーンスレッドにスケジュールされ、グリーンスレッド数より多くのゴールーチンがある場合、
スケジューラ―は利用可能なグリーンスレッドに割り振り、ブロックされたゴールーチンがあれば他のゴールーチンを実行する

GOはfork-joinモデルという並列処理のモデルに従う
分岐（fork）は、プログラムの任意の場所で子の処理を分岐させ、親と並行に実行させることを指す
合流（join）は、分岐後に並行処理が再び合流すること
つまりGOではgo func()で分岐したプロセスは各々勝手に実行される
メインプロセスが終了すると分岐プロセスは実行されずに終わる可能性もある
合流ポイントを作ることで、このプロセスの実行を担保でき、色々な方法でこれを実装できる

クロージャ―はそれが作成されたレキシカルスコープを閉じ込め、そこに変数を取り込む
ゴールーチン内でクロージャ―を実行すると、クロージャ―はこれらの変数のコピーを操作するのか？
それとも元の変数の参照に対して操作するのか？
これは元の変数の参照に対して操作を行う結果になる
また配列を扱う上で注意が必要で、ゴールーチンの実行タイミングはメインの実行よりプログラムレベルでは
結構遅れて実行されることが多いので、メインの関数は全て実行された後のメモリ参照を見ることになる場合がある
GOのランタイムはメモリの参照があることを理解しているので、
仮にスコープを抜けてもガベージコレクションに回収されることはない
参照が残っている変数はヒープ領域に移動させられるので、
その変数が最後に保持していた値をゴールーチンが参照するような形で動作する

ゴールーチンはお互いに同じアドレス空間を操作していて、
単純に関数をホストしているので、並列でないコードを書く延長線で実装できる
GOのコンパイラはゴールーチンが解放されたメモリに間違ってアクセスしないようにしている
ただし、複数のゴールーチンが同じメモリ空間を共有するので、
同期に関しては気にしなくてはいけない

ゴールーチンは非常に軽量
ゴールーチン1つにつき数キロバイトのメモリ
GOのガベージコレクターは何らかの理由で破棄されたゴールーチンにたいして回収したりしない
go func() {
    //永遠にブロックする操作
}()
//後続処理

この場合、ブロックされたゴールーチンはプロセスが終了するまで存在し続ける

○ゴールーチンの大きさの計測
先のブロックされたゴールーチンは存在し続ける性質と、
ランタイム自身が内部状態を観察してゴールーチンの生成前後で確保されたメモリ量を計測できる性質を使う
教科書だと３KBくらい、自環境だと８KBほど
数KB単位なのは間違っていない
つまり理論的には数百万とかのレベルでゴールーチンをスワップなしに起動できる

コンテキストスイッチ次第では起動できない可能性もある
コンテキストスイッチは、並列プロセスをホストしているものが、別の並列処理の実行に切り替える際に
状態の保存等を行うときにおこるもの
並列プロセスが大量にあると、その保存等の処理だけでリソースを使い切ってしまい、
本来行いたい処理が一切行われなくなる
スレッドのコンテキストスイッチは非常に高コストの可能性もある
ソフトウェア内のコンテキストスイッチはOSのコンテキストスイッチに比べればコストは少ない
実際にゴールーチンのコンテキストスイッチにかかるコストは、OSのスレッドのコンテキストスイッチに比べ、
10分の一くらいのコストで実行できる
225 ns/op や 185 ns/op（185ナノ秒）
なので基本的にゴールーチンを立てすぎたとかそういうことは気にしなくていい（使いたいだけ立てるべき）

