低水準メモリアクセス同期に便利なプリミティブが入っている

○ WaitGroup
ひとまとまりの並列処理があり、その結果を気にしない、あるいは他に結果を収集する手段があるときに、
それらの処理の完了をまつのに使える
並列処理の結果を受け取る場合はSelectの方が良い

Addで与えた数字分DoneされるのをWaitで待つ
Addは監視対象のルーチンとは切り離した方が、Add前にWaitが走らないので良い

○ MutexとRWMutex
プログラム内のクリティカルセッションを保護する方法のひとつ
共有リソースに対する排他的なアクセスが必要な場所を保護する
Unlockはdefer内で必ず呼び出すことで、panic時も確実に呼び出される
Unlockが呼ばれないとロックが解除されないので注意
ただこうしたロック処理はコストが大きいので出来るだけクリティカルセッションの面積を減らすようにする
また減らせなくても、Read、Writeが両方必要なケースは稀なので、そこをsync.RWMutexで使い分ける
sync.RWMutexだと、読み込みでロックを取得する時、書き込みのロックがかかっていなければ値を読み出せる

○ Cond
ゴールーチンが待機したり、イベントを知らせたりするためのランデブーポイント
イベントとは2つ以上のゴールーチン間で、それを発生したこと以外の情報がない任意のシグナルのこと
Condを使わずに実現する方法として無限ループがある
for conditionTrue() == false {
    //...
}
しかしこの実装だとCPUコアを占有してしまう
なのでSleepを挟むのが一般的だがスリープ時間を気にする必要が出てくるのであまり綺麗ではない
for conditionTrue() == false {
    time.Sleep(1*time.Millisecond)
    //...
}

Condを用いるとSleepを使わず効率的に待機させられる
c := sync.NewCond(&sync.Mutex{})
c.L.Lock()
for conditionTrue() == false {
    c.Wait()
}
c.L.Unlock()

Waitはただ待機するだけでなく、現在のゴールーチンを一時停止する
Waitを呼び出すと、Condの引数であるLockerのUnlockが呼ばれる
そしてWaitを抜けると同じLockerのLockが呼ばれる
見かけ上最初のLockからWait中ずっとロックをとっているように見えるが
実際はそうではないので注意が必要

WaitしているCond型に対してイベント通知する方法は2つ
1つはSignal
ゴールーチンのキューの中で最も長く待機している（先頭の）ゴールーチンに対してイベントを通知する
もう1つはBroadcast
Signalを待っている全てのゴールーチンに対してイベントを通知する
Signalの方はチャネルでも簡単に再現できるが、Broadcastの方はチャネルで再現は難しい
またCond型はチャネルを使うより性能が高い

○ Once
sync.Onceは、Doに渡された何らかの関数が、たとえ異なるゴールーチンで呼ばれていても、
1度しか実行されないことを保証する型
sync,Onceは、Doが呼ばれた回数のみ覚えているので、同じOnceに関数を2つ入れ替えても
後続の関数はDoで呼ばれることはない

○ Pool
オブジェクトプールパターンの実装
使うものを決まった数だけプールする
DB接続などコストが高いものを使うときに制限をかけるのに使う
Goのsync.Poolの場合、複数のゴールーチンから安全に使うことができる
Getメソッドによってプール内に利用可能なインスタンスがあるか確認し、あれば取得できる
もしない場合はNewメンバー変数を呼び出し、新しいインスタンスを作成する
利用後はPutメソッドにより利用したインスタンスをプールに戻し、他のプロセスが利用できるようにする

便利な場面として、可能な限り素早く実行したい操作のために、アロケート済みのオブジェクトを暖気しておくことができる
ネットワークサーバなどで多用される
Poolを使っても改善されないケースもあるが、基本的に実装の話なので
改善を期待して使ってみる感じで問題ない
    あまり効果がないケース
    ・プールしたインスタンスを利用する時にデータ変換が必要な場合
    ・プールしたインスタンスを頻繁に使わない場合（ガベージコレクションされる）
注意点
・sync.Poolをインスタンス化する際は、呼び出し時にスレッド安全なNewメンバー変数を用意する
・Getでインスタンスを取得する時、受け取るオブジェクトの状態について何かを想定してはいけない
・利用後はPutを必ず呼ぶ（通常defer定義）
・プール内のオブジェクトは均質であるべき
