並行性と並列性は違う
この2つを区別することで強力な抽象化を行うことができ、GOではこれを利用している

並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指す

例えばコードを並列に動作するように書いたとして、それが本当に並列に実行されるか？
これは真ではない
マシンのCPUが1コアなら細かい単位で逐次実行される

・我々は並列なコードを書いているのではなく、並列に走ってほしいと思うコードを書いている
・自分が書いた並行なコードが実際に並行に走っているのか知らないで済む（そうでありたい）
・並列性は時間やコンテキストの機能である

抽象化のスタックが下に行くにつれて（コード→ランタイム→OS→CPUとか）
物事を並列に処理する問題は、論理的に考えることが難しく、かつ重要になる
逆に言うと並行処理を正しく動作させることが難しくなるにつれ、
構成しやすい並行処理のプリミティブがあることが重要になる

GO以外のメジャーな言語では、OSのスレッドレベルが抽象化の最終地点で、
スレッドに合わせた実装をし、スレッド間でメモリアクセスを同期するコードを書いていた

GOではこれに対して、ゴールーチンとチャネルの概念をプリミティブとして導入している
このプリミティブはOSのスレッドの上の概念ではなく、OSのスレッドを置き換えるものである

○　CSP（Communicating Sequential Processes）
入力と出力が、並列なコードにおいて重要なプリミティブである
メモリアクセス同期ではなくメッセージパッシングによって記述することで、
並列処理を非常に簡潔に書ける
並列処理に取り組む際に、スレッドやそのプール、設計など、重要だが問題の解決に直接関係ない事を考えなくていい
GOだと並列処理に対してイメージしたことをそれにかなり近い形でコードに落とせる
ゴールーチンは軽量なので、そこにかかるコストも基本的に気にしなくていい

一方でGOではロックなどのメモリアクセス同期などのプリミティブもsyncパッケージで提供している
チャネルを必ずしも使わなくてはいけない訳ではなく、簡潔に書けるほうをその時々で使い分けるべき
ロックは使ってもいいが、出来るだけ小さなスコープにとどめる
