クラウドが普及したことにより膨大な計算リソースにアクセスできるようになった
そうした中で、システム構築をより分散的に、並列的に実行することが求められるようになった

○並列処理のむずかしさ
並列処理のコードは正しく動かすことが非常に難しい
下記のようなむずかしさがある

・競合状態
2つ以上の操作が正しい順番で実行されなければいけない時に、
プログラムが実行順序を保証しないようにかかれていると起こる
根本的な解決ではないため実行順序の保証はスリープによってしてはいけない
常に論理的正当性を目指す必要がある

・アトミック性
「何かがアトミックである」ということは、
それが操作されている特定のコンテキスト内で分割不能、ないし中断不能であることを意味する
コンテキストの考え方が大事（別の言い方でスコープ）
処理のコンテキスト内であればアトミックでも、OSレベルのコンテキストだとアトミックでないとか
そういうことは普通にありうる
アトミック性について考える時は、何のコンテキスト上でアトミックであるべきかを考える
アトミックな操作を組み合わせても、大きなアトミックは作れない
あるものがアトミックであるとき、それを複数の並列処理で安全に扱えることが保証されている
この性質によって、論理的正当性のあるコードがかける
一方でたいていの式はアトミックではない
テクニックによってアトミックであることを強制させる

・メモリアクセス同期
プログラム内で共有リソースに対する排他的なアクセスが必要な場所をクリティカルセクションという
プログラムのクリティカルセクションは守らなければいけない
一例としてLockとUnLockによりアクセスに同期性を保証できる
一方で同期的アクセスではデータ競合や論理的整合性を自動的に解決しない
また見栄えも悪くパフォーマンスも落ちる

・デッドロック、ライブロック、リソース枯渇
プログラムが正しくあっても、挙げたような問題が発生する
    ・デッドロック
    全ての並列なプロセスがお互いの処理を待ちあう状態になること
    この状態になると、プログラムは外部からの介入以外で動かなくなる
    Goのランタイムはある種のデッドロックであれば検知するが、解決にはならない
    デッドロックになるためには、達成しなければならない条件があり、コフマン条件という
        相互排他　あるプロセスがリソースに対して排他的な権利をどの時点においても保持している
        条件待ち　ある並列プロセスはリソースの保持と追加のリソース待ちを同時に行わなければならない
        横取り不可　ある並列プロセスに保持されているリソースは、そのプロセスによってのみ解放される
        循環待ち　ある並列プロセスは、他の連なっている並列プロセスを待たなければいけない、逆もしかり
    これらの条件が一つでも真にならなければデッドロックは起きない
    一方でその証明はかなり難しいので予防も難しい

    ・ライブロック
    並行操作を行ってはいるが、プログラムの状態を全く進めていない状態を指す
    ライブロックはデッドロックより発見が難しい
    CPUだけを見ていると普通にプログラムが動いているように見える

    ・リソース枯渇
    並列プロセスが仕事をするのに必要なプロセスを取得できない状況
    1つ以上のプロセスが他のプロセスの仕事を妨げているような状況で起こる

○並列処理の安全性を見極める
以上のようなむずかしさが並列処理にはある
加えてこれらの難しさに対して、実装者がいて余計に問題を難しくする
人の問題に関しては並列処理を行う関数に対してコメントを付けることで多少改善する
コメントには次の3つに必ず触れること
・誰が並列処理を担っているのか？
・問題空間がどのように並列処理のプリミティブに対応しているか
・誰が同期処理を担っているのか？
またGOのチャネルや文法を踏襲することで多少改善する


